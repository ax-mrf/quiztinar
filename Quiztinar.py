# Imports

import os
import time
import sys
import base64
import PyPDF2
import tiktoken
import markdown
from weasyprint import HTML
import tkinter as tk
from tkinter import filedialog, messagebox
from openai import OpenAI
from dotenv import load_dotenv
import re
from pathlib import Path
from tkinter import simpledialog, Text, Scrollbar
import pandas as pd

# Global variables defined
# Load OpenAI API Key
load_dotenv()
os.environ["OPENAI_API_KEY"] = os.getenv("API_KEY")
client = OpenAI()

# Define Assistant Names
# Assistant names are used later in the code to identify if the user have used the same assistants while using OpenAI
# API, and loading the assistants to the environment for use.
assistant_name_l = 'Q - Learning Objective Extractor'
assistant_name_q = 'Q - Quiz Generator'

# Define System Prompts
# If system prompts are updated, running the script will update it for the assistants in the OpenAI API
# System prompt for the first assistant: Learning Objective Extractor
system_prompt_l = """
You are a teacher assistant. Your main focus is helping students gain a better grasp of the course material through extracting the learning objectives in a PDF document. 

You process course material into bullet points highlighting the main learning objectives.

You receive the prompt in the form of an uploaded PDF that contains the course material.

In this system prompt, when I say the term "examination method", I am referring to educational goals following Bloom's Taxonomy. Those are the following:
- Remembering: simply recalling a concept.
- Understand: comprehending what the concept means.
- Apply: knowing how to apply the concept.
- Analyze: knowing how to break down information into component parts.

Learning objective bullet points generated by you must consist of the following:
- Which examination method the objective is most appropriately trying to achieve.
- The title of the learning objective.
- The pages where the learning objective is covered.

Bullet points should be sorted in importance. Most important learning objective should come first.
Learning objectives should not intersect with one another, they all must be unique.
You should generate enough learning objectives to cover the whole document.

Example reference for the format:
1. Understand the purpose and usage of positional and keyword arguments in Python functions. (Page 11) - Understand
2. Analyze the concept of modules and packages and their importance in code organization within Python. (Page 14) - Analyze
3. Apply the object-oriented programming principles of classes and objects to create and manipulate objects in Python. (Page 23) - Apply
"""
# System prompt for the second assistant: Quiz Generator
system_prompt_q = """
You are a teacher assistant. Your main focus is helping students gain a better grasp of the learning objectives of a course by testing them. You maintain a formal and efficient tone.

When I say the word "Distractors", I am referring to the incorrect choices trying to distract students from the correct answer.

When I say the term "examination method", I am referring to educational goals following Bloom's Taxonomy. Those are the following:
- Remembering: simply recalling a concept.
- Understand: comprehending what the concept means.
- Apply: knowing how to apply the concept.
- Analyze: knowing how to break down information into component parts.

You process course material and then create quizzes in the form of multiple choice questions. 

You receive the prompt in the form of an uploaded PDF file that contains the course material, and a list of learning objectives of the course. The learning objectives listed in the user prompt will contain the examination method that is most appropriate for the question generated for that learning objective.

Multiple choice questions generated by you must consist of the following:
A question, a correct answer, three distractors, an answer key, an explanation of why that answer is the correct one, and a reference to the source material, including a page number. Page number is one of the most crucial elements of the reference. An example format is as follows:
**Question 1:**  
Which color is the sky usually during a clear day?

A) Green
B) Red
C) Blue
D) Yellow

**Correct Answer:** C 
**Explanation:** The sky appears blue during a clear day because of a phenomenon called Rayleigh scattering.
**Reference:** (Page 2)

To reach the most effective quiz at helping student learn, you follow the following steps:
1- You determine if the learning objective was used in generating a quiz previously in the same thread. 
2- You prioritize learning objectives that were not used before.
3- You select a learning objective to generate a question for based on the learning objective importance, and use the material provided in the PDF covering that learning objective to create one question.
4- Do the same for a maximum of 5 questions covering 5 different learning objectives.
5- If all learning objectives have been used to generate questions, and you were asked to create more questions, you create one more question for every learning objective with a maximum of 5 questions per response, while maintaining that the questions do not repeat.

Keep within the following constraints:
- When creating the quizzes, you do not use any source material other than the uploaded file for creating the question, or the correct answer. The only part where you're allowed to use your own knowledge is when you are creating the distractors. But even when you are using your own knowledge, you do not fabricate any information.
- Distractors should be plausible by being relevant to the question and/or the correct answer. However, it should not be open to interpretation that the distractor is correct or incorrect. It should be undisputed that it is incorrect. 
- Do not generate a correct answer that can be identified by being too long compared to its distractors.
- Do not give grammar hints.
- Use only positive wording. Avoid using NOT or EXCEPT as much as possible. 
- Avoid "All of the above" and "None of the Above" formats. Those formats use the distractors in a different way than what we want to achieve.
- Use random distribution for correct answers across the choices (A, B, C and D).
- Avoid using overly complex language, use the same level of language complexity provided in the source material.
- Do not ask meta questions, example of meta questions is whether a concept is mentioned in the document or not.
"""


# While trying to figure out how tokenization work in OpenAI API, I added a token counter as an indication
# Tokens displayed by token counter are far from the requested number, but usually an indication if it will exceed the limit
# When the text from the PDF contains around 5000 tokens or more in text format, it usually suggests that the token count will exceed the 30,000 token limit
def extract_text_from_pdf(file_path):
    """Extract text from a PDF file."""
    text = ""
    with open(file_path, "rb") as pdf_file:
        reader = PyPDF2.PdfReader(pdf_file)
        for page in reader.pages:
            text += page.extract_text()
    return text

def count_tokens(text, model="gpt-4-32k"):
    """Count tokens using tiktoken."""
    enc = tiktoken.encoding_for_model(model)
    tokens = enc.encode(text)
    return len(tokens)


# When one PDF is selected, user gets the option to split it into chapters, since this code works best when the PDF has only one main topic or chapter
# User has to identify the page ranges on which the chapters are split
# The correct syntax for one chapter is start-end, separated by a whitespace e.g: '1-20 21-40 41-50' for a pdf to be split into 3 chapters
def split_pdfs(instructions):
    """Splits a PDF into multiple parts based on specified page ranges."""
    split_files = []  
    for instruction in instructions:
        input_file = instruction["file"]
        split_ranges = instruction["ranges"]
        
        with open(input_file, "rb") as pdf:
            reader = PyPDF2.PdfReader(pdf)
            total_pages = len(reader.pages)
            
            print(f"Splitting '{input_file}' ({total_pages} pages)...")
            
            for i, (start, end) in enumerate(split_ranges):
                output_file = f"{input_file.replace('.pdf', '')}_part_{i+1}.pdf"
                
                if start < 1 or end > total_pages:
                    print(f"Error: Range {start}-{end} is out of bounds for '{input_file}'")
                    continue
                
                writer = PyPDF2.PdfWriter()
                for page in range(start - 1, end):  
                    writer.add_page(reader.pages[page])
                
                with open(output_file, "wb") as output_pdf:
                    writer.write(output_pdf)
                
                print(f"Created: {output_file}")
                split_files.append(output_file)
    
    return split_files    


# When a file is selected its name is compared to files already uploaded onto OpenAI, when that matches, it compares the size in bytes, when that matches, the file is not uploaded and the file ID is retrieved for the rest of the script to run.

# This is useful for two main case scenarios: a syllabus is updated with the same name, size (in bytes) can give it away and will act accordingly by uploading the new file.
# Second case is if the user split the syllabus first time into chapters and changed their mind later on how the pages are split.

def get_file_id(files, file_path):
    """Retrieve file ID from OpenAI by comparing the base file name."""
    # Extract the base file name from the full path
    base_name = os.path.basename(file_path).strip().lower()
    
    for file in files.data:
        if file.filename.strip().lower() == base_name:
            return file.id
    return None

def get_file_size(file_path):
    """Get the size of a file in bytes."""
    return os.path.getsize(file_path)


# Retrieving assistant IDs by name helps keep OpenAI API clean without many created assistants every time there is a modification
def get_assistant_id_by_name(my_assistants, name):
    """Retrieve assistant ID from OpenAI."""
    for assistant in my_assistants:
        if assistant.name == name:
            return assistant.id
    return None


# This is the main function for retrieving the generated content by the assistants.
# Main feature of the function: poll for an updated response before saving it into the collected output.
# Other features: if user chose to confirm and modify learning objectives of the course, it opens a window for that
def wait_for_assistant_response(messages, thread, LO, course, run, confirm_modify_lo=False, log_function=print):
    while True:
        try:
            latest_message = messages.data[0] # Save last message output
            if latest_message.role == 'assistant':
                if LO:
                    learning_objectives = messages.data[0].content[0].text.value

                    # If the user wants to confirm and modify learning objectives
                    if confirm_modify_lo:
                        # Open a dialog for the user to edit the learning objectives
                        root = tk.Tk()
                        root.withdraw()  
                        app = QuiztinarGUI(root)
                        modified_lo = app.confirm_and_modify_learning_objectives(learning_objectives)
                        root.destroy()

                        # Use the modified learning objectives
                        learning_objectives = modified_lo

                    # Convert the learning objectives to PDF using markdown
                    html_content = markdown.markdown(learning_objectives)
                    safe_filename = re.sub(r'[^\w\-_. ]', '_', Path(course).stem)
                    output_path = Path(course).parent / f"LOs_for_{safe_filename}.pdf"
                    HTML(string=html_content).write_pdf(str(output_path))
                    log_function(f"Learning objectives saved to: {output_path}")

                    # Return the learning objectives
                    return learning_objectives
                else:
                    capture_output(messages.data[0].content[0].text.value)
                break
        except (IndexError, AttributeError) as e:
            time.sleep(4)
        run = client.beta.threads.runs.retrieve(thread_id=thread.id, run_id=run.id)
        if run.status == 'failed':
            log_function(f"Run failed: {run.last_error.message}")
            sys.exit()
            break
        messages = client.beta.threads.messages.list(thread_id=thread.id)

# In case that the user decided to generate more than 1 quiz (5 questions)
# Maximum number of quizzes allowed is hardcoded to 10 (50 questions). Please modify to your liking on your own responsibility while putting in mind token and usage limitations of OpenAI API
def generate_more(repeat_function, iterations, thread_qu, messages_qu, assistant_id_q, course, log_function):
    if iterations <= 0:
        log_function("Only one quiz is requested.")
        return
        
    if iterations > 9:
        log_function("Maximum quiz limit is 10. Adjusting quiz generation to 10.")
        iterations = 9
        
    for i in range(iterations):
        log_function(f"Generating Quiz {i + 2}...")
        repeat_function(thread_qu, messages_qu, assistant_id_q, course, log_function)


# Generating 5 more questions for the quiz
# This function includes a coded time delay of 60 seconds before every run to ensure the process isn't broken because of TPM (tokens allowed per minute) limitations.
def repeat_quiz(thread_qu, messages_qu, assistant_id_q, course, log_function):
    message_qu = client.beta.threads.messages.create(
        thread_id=thread_qu.id,
        role="user",
        content="Generate 5 more unique questions to add to this quiz"
    )

    time.sleep(60)
    
    run = client.beta.threads.runs.create(
        thread_id=thread_qu.id,
        assistant_id=assistant_id_q
    )

    time.sleep(6)
    
    wait_for_assistant_response(messages_qu, thread_qu, False, course, run, log_function=log_function)

    time.sleep(6)
    log_function("Quiz Generated!")

def capture_output(output):
    collected_output.append(output)


# In this part the output is processed into CSV by using regular expression.
# This is made to facilitate further processing the generated content, or integrating it with another platform's API or data import/entry features.
import re
import pandas as pd
from pathlib import Path

def process_quiz_output_to_csv(collected_output, file_path, log_function=print):
    """
    Process the quiz output into a DataFrame and save it as a CSV file.
    
    """
    # Define regex patterns to extract quiz data
    question_pattern = re.compile(
        r"\*\*Question (\d{1,2}):\*\*\s*(.+?)\n"  # Question number and stem
        r"A\) (.+?)\n"                            # Choice A 
        r"B\) (.+?)\n"                            # Choice B 
        r"C\) (.+?)\n"                            # Choice C 
        r"D\) (.+?)\n"                            # Choice D 
        r"\*\*Correct Answer:\*\* (.+?)\n"        # Key
        r"\*\*Explanation:\*\* (.+?)\n"           # Explanation
        r"\*\*Reference:\*\* (.+?)\n",            # Reference
        re.DOTALL
    )

    # Initialize a list to store extracted data
    quiz_data = []

    # Iterate through the collected output and extract data
    for output in collected_output:
        matches = question_pattern.findall(output)
        for match in matches:
            question_number, stem, choice_a, choice_b, choice_c, choice_d, key, explanation, reference = match
            quiz_data.append({
                "Question number": question_number.strip(),
                "Stem": stem.strip(),
                "Choice A": choice_a.strip(),
                "Choice B": choice_b.strip(),
                "Choice C": choice_c.strip(),
                "Choice D": choice_d.strip(),
                "Key": key.strip(),
                "Explanation": explanation.strip(),
                "Reference": reference.strip()
            })

    # Convert the list of dictionaries to a DataFrame
    df = pd.DataFrame(quiz_data)

    # Save the DataFrame to a CSV file
    safe_filename = re.sub(r'[^\w\-_. ]', '_', Path(file_path).stem)  # Remove special characters
    output_csv_path = Path(file_path).parent / f"Quiz_for_{safe_filename}.csv"
    df.to_csv(output_csv_path, index=False)

    # Log the creation of the CSV file
    log_function(f"CSV file created: {output_csv_path}")

# This part is the main code running all of the requests with OpenAI API using the previous functions in their desired order. This is made to run on one PDF.
# In between run requests is also an added time delay to ensure the code is not interrupted by TPM (tokens per minute) limitations.
def repeat_pdf(file_path, quiz_count, assistant_id_l, assistant_id_q, file_id, confirm_modify_lo=False, log_function=print):
    """Handles OpenAI interaction for learning objectives and quiz generation."""
    log_function(f"Processing: {file_path}")

    global collected_output
    collected_output = []
    
    try:
        # Start a thread for LO Extractor
        thread_lo = client.beta.threads.create()
        log_function("LO Extractor thread created!")

        # Create first message for LO Extractor
        message = client.beta.threads.messages.create(
            thread_id=thread_lo.id,
            role="user",
            content="Extract the learning objectives from the file attached.",
            attachments=[{"file_id": file_id, "tools": [{"type": "file_search"}, {"type": "code_interpreter"}]}]
        )
        log_function("Message sent to LO Extractor!")
        time.sleep(60)  # To make sure API requests are not interrupted by TPM limits

        # Run the thread to generate assistant message
        run = client.beta.threads.runs.create(
            thread_id=thread_lo.id,
            assistant_id=assistant_id_l
        )
        log_function("Thread ran! Awaiting LO Extractor response!")

        # Update thread messages
        messages_lo = client.beta.threads.messages.list(thread_id=thread_lo.id)

        # Request assistant's response to process as soon as they are available
        learning_objectives = wait_for_assistant_response(
            messages_lo, thread_lo, True, file_path, run, confirm_modify_lo, log_function
        )
        log_function("LOs for course created in pdf format!")

        # Update thread messages
        messages_lo = client.beta.threads.messages.list(thread_id=thread_lo.id)

        # Extract learning objectives from the LO Extractor response
        log_function("Learning Objectives Extracted:")
        log_function(learning_objectives)

        # Start a thread for Quiz Generator
        thread_qu = client.beta.threads.create()
        log_function("Quiz Generator thread created!")

        # Create first message for Quiz Generator using the extracted learning objectives
        message_qu = client.beta.threads.messages.create(
            thread_id=thread_qu.id,
            role="user",
            content=f"Generate a quiz according to the following learning objectives: {learning_objectives}",
            attachments=[{"file_id": file_id, "tools": [{"type": "file_search"}, {"type": "code_interpreter"}]}]
        )
        log_function("Message sent to Quiz Generator!")

        # Run the assistant
        time.sleep(60)
        run = client.beta.threads.runs.create(
            thread_id=thread_qu.id,
            assistant_id=assistant_id_q
        )
        log_function("Thread ran! Awaiting Quiz Generator response!")

        # Update thread messages
        messages_qu = client.beta.threads.messages.list(thread_id=thread_qu.id)

        # Request assistant response as soon as they are available
        wait_for_assistant_response(messages_qu, thread_qu, False, file_path, run, log_function=log_function)
        log_function("Quiz 1 generated!")

        # Generate more quizzes
        num_of_quizzes = quiz_count - 1
        generate_more(repeat_quiz, num_of_quizzes, thread_qu, messages_qu, assistant_id_q, file_path, log_function)

    except Exception as e:
        log_function(f"An error occurred: {e}")
        log_function("Saving the generated quizzes so far...")

    finally:
        # Save quiz outputs into one PDF
        if collected_output:
            log_function("Saving quiz in pdf")
            markdown_content = "\n\n".join(collected_output)
            html_content = markdown.markdown(markdown_content)
            safe_filename = re.sub(r'[^\w\-_. ]', '_', Path(file_path).stem)  # Removes special characters
            output_path = Path(file_path).parent / f"Quiz_for_{safe_filename}.pdf"
            HTML(string=html_content).write_pdf(str(output_path))
            log_function(f"PDF successfully saved at: {output_path}")

            # Process quiz output into CSV
            process_quiz_output_to_csv(collected_output, file_path, log_function)
        else:
            log_function("No quizzes were generated to save.")


# This part is the entire pipeline.
# It starts with splitting the PDF if desired.
# Then verifies the OpenAI assistants
# Then verifies every PDF selected and puts it in order to run the repeat_pdfs function on every one
def process_pdfs(files, quiz_count, split, split_instructions, confirm_modify_lo, log_function):
    """Runs the full pipeline for processing PDFs and generating quizzes."""
    try:
        log_function(f"Processing {len(files)} files with {quiz_count} quizzes each.")

        if split:
            log_function("Splitting PDFs...")
            # Format split_instructions correctly
            split_instructions = [
                {"file": file, "ranges": split_instructions}
                for file in files
            ]
            split_files = split_pdfs(split_instructions)
            files = split_files  # Use the split PDFs instead of the originals

        # Ensure OpenAI Assistants Exist
        my_assistants = client.beta.assistants.list(order="desc", limit="50")
        
        assistant_id_l = get_assistant_id_by_name(my_assistants, assistant_name_l)
        assistant_id_q = get_assistant_id_by_name(my_assistants, assistant_name_q)

        if assistant_id_l is None:
            assistant_id_l = client.beta.assistants.create(
                instructions=system_prompt_l,
                name=assistant_name_l,
                tools=[{"type": "file_search"}, {"type": "code_interpreter"}],
                model="gpt-4o",
            ).id
            log_function("Learning Objective Extractor created!")

        if assistant_id_q is None:
            assistant_id_q = client.beta.assistants.create(
                instructions=system_prompt_q,
                name=assistant_name_q,
                tools=[{"type": "file_search"}, {"type": "code_interpreter"}],
                model="gpt-4o",
            ).id
            log_function("Quiz Generator created!")

        for file in files:
            log_function(f"Processing file: {file}")

            # Extract text and count tokens
            text = extract_text_from_pdf(file)
            token_count = count_tokens(text)
            log_function(f"Total Tokens for {file}: {token_count}")

            # Upload to OpenAI if needed
            uploaded_files = client.files.list()
            file_id = get_file_id(uploaded_files, file)
            
            if file_id is not None:
                # Get the size of the local file and the file in OpenAI
                local_file_size = get_file_size(file)
                openai_file_info = client.files.retrieve(file_id)
                openai_file_size = openai_file_info.bytes

                if openai_file_size == local_file_size:
                    # File sizes match, skip upload
                    log_function(f"File '{file}' already exists in OpenAI with the same size. Using existing file ID: {file_id}")
                else:
                    # File sizes differ, upload the new file
                    log_function(f"File '{file}' exists in OpenAI but has a different size. Uploading new version...")
                    try:
                        response = client.files.create(
                            file=open(file, "rb"),
                            purpose="assistants"
                        )
                        file_id = response.id
                        log_function(f"File '{file}' uploaded successfully!")
                    except Exception as e:
                        log_function(f"Error uploading '{file}': {e}")
                        continue
            else:
                # File does not exist in OpenAI, upload it
                try:
                    response = client.files.create(
                        file=open(file, "rb"),
                        purpose="assistants"
                    )
                    file_id = response.id
                    log_function(f"File '{file}' uploaded successfully!")
                except Exception as e:
                    log_function(f"Error uploading '{file}': {e}")
                    continue

            # Process file through OpenAI pipeline
            repeat_pdf(file, quiz_count, assistant_id_l, assistant_id_q, file_id, confirm_modify_lo, log_function)

        log_function("Processing complete!")
    except SystemExit as e:
        # Handle the case where the user closed the progress window manually
        log_function(str(e))
        raise  # Re-raise the exception to stop the script
    except Exception as e:
        # Handle other errors
        log_function(f"An error occurred: {e}")

# Window to display every step of the way in case the user needed to debug or verify output
class ProgressWindow:
    def __init__(self, root):
        self.root = root
        self.window = tk.Toplevel(root)
        self.window.title("Progress")
        self.window.geometry("600x400")

        # Add a Text widget to display progress
        self.text_area = tk.Text(self.window, wrap=tk.WORD, width=80, height=20)
        self.text_area.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        # Add a scrollbar
        scrollbar = tk.Scrollbar(self.window, command=self.text_area.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.text_area.config(yscrollcommand=scrollbar.set)

        # Track whether the window was closed manually
        self.closed_manually = False

        # Bind the window close event to a handler
        self.window.protocol("WM_DELETE_WINDOW", self.on_close)

    def log(self, message):
        """Append a message to the Text widget."""
        if not self.closed_manually:
            self.text_area.insert(tk.END, message + "\n")
            self.text_area.see(tk.END)  # Scroll to the bottom
            self.window.update_idletasks()  # Update the window

    def on_close(self):
        """Handle the window close event."""
        self.closed_manually = True
        self.window.destroy()
        # Stop the script and return to the main GUI window
        raise SystemExit("Progress window closed by user.")
        
# GUI Class
# GUI Class
class QuiztinarGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Quiztinar")

        # File selection
        tk.Label(root, text="Select PDF Files:").grid(row=0, column=0, padx=10, pady=5)
        self.file_list = []
        self.file_label = tk.Label(root, text="No files selected", wraplength=300)
        self.file_label.grid(row=0, column=1, columnspan=2)
        tk.Button(root, text="Browse", command=self.browse_files).grid(row=0, column=3)

        # Explanation for file selection
        file_selection_explanation = (
            "You can select multiple PDF files. The program will process them sequentially, "
            "generating quizzes for each file. \n \n Only PDF files are supported."
        )
        tk.Label(root, text=file_selection_explanation, wraplength=400, justify=tk.LEFT).grid(row=0, column=4, padx=10, pady=5)

        # Number of quizzes
        self.quiz_count = tk.IntVar(value=2)
        tk.Label(root, text="Number of Quizzes per file:").grid(row=1, column=0, padx=10, pady=5)
        tk.Entry(root, textvariable=self.quiz_count).grid(row=1, column=1)

        # Explanation for number of quizzes
        quiz_explanation = (
            "Each quiz contains 5 questions. For example, if you specify 3 quizzes, "
            "the program will generate 15 questions in total.\n"
            "The program is limited to a maximum of 10 quizzes (50 questions) to avoid billing problems."
        )
        tk.Label(root, text=quiz_explanation, wraplength=400, justify=tk.LEFT).grid(row=1, column=2, columnspan=2, padx=10, pady=5)

        # Split PDF into chapters
        self.split = tk.BooleanVar(value=False)
        self.split_checkbox = tk.Checkbutton(
            root, text="Split PDF into Chapters", variable=self.split, command=self.toggle_split_input
        )
        self.split_checkbox.grid(row=2, column=0, padx=10, pady=5)

        # Explanation for splitting PDF
        split_explanation = (
            "The quiz generator works best with one chapter at a time. "
            "If your course material contains multiple chapters, it is recommended to split the PDF into chapters. Every chapter will be treated as if it's a separate file \n\n"
            "This option is not available when you are selecting multiple courses for sequential processing. \n\n"
            "Each range entered is considered one chapter. "
        )
        tk.Label(root, text=split_explanation, wraplength=400, justify=tk.LEFT).grid(row=2, column=2, columnspan=2, padx=10, pady=5)

        # Split instructions input (hidden by default)
        self.split_instructions_label = tk.Label(root, text="Enter page ranges (e.g., '1-20 21-33'):")
        self.split_instructions_entry = tk.Entry(root, width=30)
        self.split_instructions_label.grid(row=3, column=0, padx=10, pady=5)
        self.split_instructions_entry.grid(row=3, column=1, padx=10, pady=5)
        self.split_instructions_label.grid_remove()  # Hide initially
        self.split_instructions_entry.grid_remove()  # Hide initially

        # Confirm and modify learning objectives
        self.confirm_modify_lo = tk.BooleanVar(value=False)
        tk.Checkbutton(
            root, text="Confirm and modify learning objectives?", variable=self.confirm_modify_lo
        ).grid(row=4, column=0, padx=10, pady=5)

        # Explanation for confirming and modifying learning objectives
        lo_explanation = (
            "Learning objectives will be automatically extracted from the course content and used for quiz generation. "
            "This option allows you to review and edit the generated learning objectives. "
            "It is recommended to maintain the same format for best results."
        )
        tk.Label(root, text=lo_explanation, wraplength=400, justify=tk.LEFT).grid(row=4, column=2, columnspan=2, padx=10, pady=5)

        # Run script button
        tk.Button(root, text="Run Script", command=self.run_script).grid(row=5, column=1, pady=10)

    def browse_files(self):
        """Open file dialog to select PDF files."""
        self.file_list = filedialog.askopenfilenames(filetypes=[("PDF Files", "*.pdf")])
        self.file_label.config(text="\n".join(self.file_list))

        # Show or hide the split option based on the number of files selected
        if len(self.file_list) == 1:
            # Show the split option if only one file is selected
            self.split_checkbox.grid()
            self.toggle_split_input()  # Update the visibility of the split instructions
        else:
            # Hide the split option if multiple files are selected
            self.split_checkbox.grid_remove()
            self.split_instructions_label.grid_remove()
            self.split_instructions_entry.grid_remove()

    def toggle_split_input(self):
        """Show or hide the split instructions input field based on the checkbox state."""
        if self.split.get() and len(self.file_list) == 1:
            self.split_instructions_label.grid()
            self.split_instructions_entry.grid()
        else:
            self.split_instructions_label.grid_remove()
            self.split_instructions_entry.grid_remove()

    def parse_split_instructions(self, input_str):
        """Parse the input string into a list of tuples."""
        try:
            ranges = input_str.strip().split()
            split_instructions = []
            for r in ranges:
                start, end = map(int, r.split("-"))
                split_instructions.append((start, end))
            return split_instructions
        except Exception as e:
            messagebox.showerror("Invalid Input", f"Invalid range format: {e}")
            return None
            
    def confirm_and_modify_learning_objectives(self, learning_objectives):
        """Display a message box with editable learning objectives and wait for user confirmation."""
        # Create a new window for editing learning objectives
        edit_window = tk.Toplevel(self.root)
        edit_window.title("Edit Learning Objectives")
    
        # Add a text area with scrollbar
        text_area = Text(edit_window, wrap=tk.WORD, width=80, height=20)
        text_area.insert(tk.END, learning_objectives)
        text_area.grid(row=0, column=0, padx=10, pady=10)
    
        scrollbar = Scrollbar(edit_window, command=text_area.yview)
        scrollbar.grid(row=0, column=1, sticky="ns")
        text_area.config(yscrollcommand=scrollbar.set)
    
        # Variable to store the modified learning objectives
        modified_lo = learning_objectives
    
        # Add a confirm button
        def on_confirm():
            nonlocal modified_lo
            modified_lo = text_area.get("1.0", tk.END).strip()  # Get the content before destroying the window
            edit_window.destroy()
    
        tk.Button(edit_window, text="Confirm", command=on_confirm).grid(row=1, column=0, pady=10)
    
        # Wait for the user to confirm
        edit_window.wait_window()
    
        # Return the modified learning objectives
        return modified_lo

    def run_script(self):
        """Run the script with the provided inputs."""
        # Create a progress window
        self.progress_window = ProgressWindow(self.root)
    
        try:
            if self.split.get():
                # Parse split instructions from the input field
                split_instructions_input = self.split_instructions_entry.get()
                split_instructions = self.parse_split_instructions(split_instructions_input)
                if split_instructions is None:
                    return  # Stop if parsing fails
            else:
                split_instructions = []
    
            # Process the PDFs
            process_pdfs(
                self.file_list,
                self.quiz_count.get(),
                self.split.get(),
                split_instructions,
                self.confirm_modify_lo.get(),
                self.progress_window.log  # Pass the log function to process_pdfs
            )
        except SystemExit as e:
            # Handle the case where the user closed the progress window manually
            self.progress_window.log(str(e))
            return  # Stop the script and return to the main GUI window
        except Exception as e:
            # Handle other errors
            self.progress_window.log(f"An error occurred: {e}")
        finally:
            # Keep the progress window open after the script finishes
            self.progress_window.log("Processing complete!")


root = tk.Tk()
app = QuiztinarGUI(root)
root.mainloop()